{"version":3,"file":"OutputTest.js","sourceRoot":"","sources":["../../lib/OutputTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { INCOMING_SOUND_URL, TestNames } from './constants';\nimport {\n  AlreadyStoppedError,\n  DiagnosticError,\n  InvalidOptionsError,\n  UnsupportedError,\n} from './errors';\nimport {\n  Audio,\n  AudioContext,\n  AudioContextUnsupportedError,\n  AudioUnsupportedError,\n  enumerateDevices,\n} from './polyfills';\nimport { getDefaultDevices } from './polyfills/enumerateDevices';\nimport { AudioElement, SubsetRequired, TimeMeasurement } from './types';\nimport { detectSilence } from './utils';\nimport {\n  InvalidityRecord,\n  validateDeviceId,\n  validateOptions,\n  validateTime,\n} from './utils/optionValidation';\n\nexport declare interface OutputTest {\n  /**\n   * This event is emitted when the test ends.\n   * @param event [[OutputTest.Events.End]]\n   * @param didPass A boolean representing the passing state of the test.\n   * @param report A summary of the test.\n   * @private\n   */\n  emit(\n    event: OutputTest.Events.End,\n    didPass: boolean,\n    report: OutputTest.Report,\n  ): boolean;\n  /**\n   * This event is emitted when the test encounters an error, fatal or not.\n   * @param event [[OutputTest.Events.Error]]\n   * @param error An error that was encountered during the run time of the test.\n   * @private\n   */\n  emit(\n    event: OutputTest.Events.Error,\n    error: DiagnosticError,\n  ): boolean;\n  /**\n   * This event is emitted by the test after succesfully starting, and emits\n   * the volume of the audio source every [[OutputTest.Options.pollIntervalMs]]\n   * milliseconds.\n   * @param event [[OutputTest.Events.Volume]]\n   * @param value The volume of the audio source.\n   * @private\n   */\n  emit(\n    event: OutputTest.Events.Volume,\n    value: number,\n  ): boolean;\n\n  /**\n   * Raised when the test ends. The stop condition depends on if the option\n   * to loop was set to `true` or `false`. If `false`, then the test ends either\n   * when the audio file is finished playing, or when a time has elapsed\n   * greater than [[OutputTest.Options.duration]].\n   * @event\n   * @param event [[OutputTest.Events.End]]\n   * @param listener A listener function that expects the following parameters\n   * when the event is raised:\n   * - A boolean representing whether or not the test passed.\n   * - A [[OutputTest.Report]] that summarizes the run time of the test.\n   * @returns This [[OutputTest]] instance.\n   */\n  on(\n    event: OutputTest.Events.End,\n    listener: (didPass: boolean, report: OutputTest.Report) => any,\n  ): this;\n  /**\n   * Raised when the test has run into an error, fatal or not.\n   * @event\n   * @param event [[OutputTest.Events.Error]]\n   * @param listener A listener function that expects the following parameters\n   * when the event is raised:\n   * - The [[DiagnosticError]].\n   * @returns This [[OutputTest]] instance.\n   */\n  on(\n    event: OutputTest.Events.Error,\n    listener: (error: DiagnosticError) => any,\n  ): this;\n  /**\n   * Raised every [[OutputTest.Options.pollIntervalMs]] after the test\n   * starts successfully. Will have a `number` parameter representing the\n   * current volume of the audio file.\n   * @event\n   * @param event [[OutputTest.Events.Volume]]\n   * @param listener A listener function that expects the following parameters\n   * when the event is raised:\n   * - A number representing the volume of the audio source.\n   * @returns This [[OutputTest]] instance.\n   */\n  on(\n    event: OutputTest.Events.Volume,\n    listener: (value: number) => any,\n  ): this;\n}\n\n/**\n * Supervises an output device test by playing a sound clip that is either the\n * ringing tone for the Client SDK, or defined by the member `testURI` in the\n * `options` parameter.\n *\n * If the data at `testURI` is unable to be loaded, meaning the error event is\n * raised on the audio element, then the test ends immediately with an error in\n * the report.\n *\n * If `doLoop` is set to `false`, then the test will run for either the option\n * `duration`, or the full duration of the audio file, which ever is shorter.\n * If `doLoop` is set to `true`, it will only run as long as the `duration`\n * option.\n * If the test times out (as defined by the `duration` in the `options`\n * paramater), then the test is considered passing or not by the `passOnTimeout`\n * option and ends.\n *\n * If the more than 50% of the volume levels are silent, then the test is considered failing.\n */\nexport class OutputTest extends EventEmitter {\n  /**\n   * The name of the test.\n   */\n  static testName: TestNames.OutputAudioDevice = TestNames.OutputAudioDevice;\n  /**\n   * Default options for the [[OutputTest]]. Overwritten by any option passed\n   * during the construction of the test.\n   */\n  private static defaultOptions: OutputTest.InternalOptions = {\n    audioContextFactory: AudioContext,\n    audioElementFactory: Audio,\n    debug: false,\n    doLoop: true,\n    duration: Infinity,\n    enumerateDevices,\n    passOnTimeout: true,\n    pollIntervalMs: 100,\n    testURI: INCOMING_SOUND_URL,\n  };\n\n  /**\n   * An `AudioContext` that is used to process the audio source.\n   */\n  private _audioContext: AudioContext | null = null;\n  /**\n   * An `AudioElement` that is attached to the DOM to play audio.\n   */\n  private _audioElement: AudioElement | null = null;\n  /**\n   * The default media devices when starting the test.\n   */\n  private _defaultDevices: Partial<Record<\n    MediaDeviceKind,\n    MediaDeviceInfo\n  >> = {};\n  /**\n   * A timestamp of when the test ends.\n   */\n  private _endTime: number | null = null;\n  /**\n   * An array of errors encountered by the test during its run time.\n   */\n  private readonly _errors: DiagnosticError[] = [];\n  /**\n   * Options passed to and set in the constructor to be used during the run\n   * time of the test.\n   */\n  private _options: OutputTest.InternalOptions;\n  /**\n   * A Promise that resolves when the `AudioElement` successfully starts playing\n   * audio. Will reject if not possible.\n   */\n  private _playPromise: Promise<void> | null = null;\n  /**\n   * A timestamp of when the test starts. This is set in the constructor and not\n   * when the test succesfully starts.\n   */\n  private _startTime: number;\n  /**\n   * Volume values generated by the test over its run time.\n   */\n  private readonly _values: number[] = [];\n  /**\n   * Timeout created by `setTimeout`, used to loop the volume logic.\n   */\n  private _volumeTimeout: NodeJS.Timeout | null = null;\n\n  /**\n   * Sets up several things for the `OutputTest` to run later in the\n   * `_startTest` function.\n   * An `AudioContext` is created if none is passed in the `options` parameter\n   * and the `_startTime` is immediately set.\n   * @param options\n   */\n  constructor(options?: OutputTest.Options) {\n    super();\n\n    this._options = { ...OutputTest.defaultOptions, ...options };\n\n    this._startTime = Date.now();\n\n    // We need to use a `setTimeout` here to prevent a race condition.\n    // This allows event listeners to bind before the test starts.\n    setTimeout(() => this._startTest());\n  }\n\n  /**\n   * Stops the test.\n   * @param pass whether or not the test should pass. If set to false, will\n   * override the result from determining whether audio is silent from the collected volume values.\n   */\n  stop(pass: boolean = true): OutputTest.Report | undefined {\n    if (this._endTime) {\n      this._onWarning(new AlreadyStoppedError());\n      return;\n    }\n\n    // Clean up the test.\n    this._cleanup();\n\n    this._endTime = Date.now();\n    const report: OutputTest.Report = {\n      deviceId: this._options.deviceId || (\n        this._defaultDevices.audiooutput &&\n        this._defaultDevices.audiooutput.deviceId\n      ),\n      didPass: pass && !detectSilence(this._values),\n      errors: this._errors,\n      testName: OutputTest.testName,\n      testTiming: {\n        duration: this._endTime - this._startTime,\n        end: this._endTime,\n        start: this._startTime,\n      },\n      testURI: this._options.testURI,\n      values: this._values,\n    };\n    this.emit(OutputTest.Events.End, report.didPass, report);\n\n    return report;\n  }\n\n  /**\n   * Cleanup the test.\n   */\n  private _cleanup(): void {\n    if (this._volumeTimeout) {\n      clearTimeout(this._volumeTimeout);\n    }\n    if (this._audioContext) {\n      this._audioContext.close();\n    }\n    if (this._playPromise) {\n      this._playPromise.then(() => {\n        // we need to try to wait for the call to play to finish before we can\n        // pause the audio\n        if (this._audioElement) {\n          this._audioElement.pause();\n        }\n      }).catch(() => {\n        // this means play errored out so we do nothing\n      });\n    }\n  }\n\n  /**\n   * Error event handler. Adds the error to the internal list of errors that is\n   * forwarded in the report.\n   * @param error\n   */\n  private _onError(error: DiagnosticError): void {\n    this._errors.push(error);\n    this.emit(OutputTest.Events.Error, error);\n  }\n\n  /**\n   * Volume event handler, adds the value to the list `_values` and emits it\n   * under the event `volume`.\n   * @param volume\n   */\n  private _onVolume(volume: number): void {\n    this._values.push(volume);\n    this.emit(OutputTest.Events.Volume, volume);\n  }\n\n  /**\n   * Warning event handler.\n   * @param warning\n   */\n  private _onWarning(error: DiagnosticError): void {\n    if (this._options.debug) {\n      // tslint:disable-next-line no-console\n      console.warn(error);\n    }\n  }\n\n  /**\n   * Entry point of the test, called after setup in the constructor.\n   * Emits the volume levels of the audio.\n   * @event `OutputTest.Events.Volume`\n   */\n  private async _startTest(): Promise<void> {\n    try {\n      // Try to validate all of the inputs before starting the test.\n      // We perform this check here so if the validation throws, it gets handled\n      // properly as a fatal-error and we still emit a report with that error.\n      const invalidReasons: InvalidityRecord<OutputTest.Options> | undefined =\n        await validateOptions<OutputTest.Options>(this._options, {\n          deviceId: validateDeviceId,\n          duration: validateTime,\n          pollIntervalMs: validateTime,\n        });\n\n      if (invalidReasons) {\n        throw new InvalidOptionsError(invalidReasons);\n      }\n\n      if (!this._options.audioContextFactory) {\n        throw AudioContextUnsupportedError;\n      }\n      this._audioContext = new this._options.audioContextFactory();\n\n      if (!this._options.audioElementFactory) {\n        throw AudioUnsupportedError;\n      }\n      this._audioElement =\n        new this._options.audioElementFactory(this._options.testURI);\n      this._audioElement.setAttribute('crossorigin', 'anonymous');\n      this._audioElement.loop = !!this._options.doLoop;\n\n      if (this._options.deviceId) {\n        if (this._audioElement.setSinkId) {\n          await this._audioElement.setSinkId(this._options.deviceId);\n        } else {\n          // Non-fatal error\n          this._onError(new UnsupportedError(\n            'A `deviceId` was passed to the `OutputTest` but `setSinkId` is ' +\n            'not supported in this browser.',\n          ));\n        }\n      }\n\n      const source: MediaElementAudioSourceNode =\n        this._audioContext.createMediaElementSource(this._audioElement);\n      source.connect(this._audioContext.destination);\n\n      const analyser: AnalyserNode = this._audioContext.createAnalyser();\n      analyser.smoothingTimeConstant = 0.4;\n      analyser.fftSize = 64;\n      source.connect(analyser);\n\n      const frequencyDataBytes: Uint8Array =\n        new Uint8Array(analyser.frequencyBinCount);\n      const volumeEvent: () => void = (): void => {\n        if (this._endTime) {\n          return;\n        }\n\n        analyser.getByteFrequencyData(frequencyDataBytes);\n        const volume: number =\n          frequencyDataBytes.reduce(\n            (sum: number, val: number) => sum + val,\n            0,\n          ) / frequencyDataBytes.length;\n        this._onVolume(volume);\n\n        // Check stop conditions\n        const isTimedOut: boolean =\n          Date.now() - this._startTime > this._options.duration;\n        const stop: boolean = this._options.doLoop\n          ? isTimedOut\n          : (this._audioElement && this._audioElement.ended) || isTimedOut;\n\n        if (stop) {\n          if (this._options.passOnTimeout === false) {\n            this._onError(new DiagnosticError(\n              undefined,\n              'Test timed out.',\n            ));\n          }\n          this.stop(this._options.passOnTimeout);\n        } else {\n          this._volumeTimeout = setTimeout(\n            volumeEvent,\n            this._options.pollIntervalMs,\n          );\n        }\n      };\n\n      this._playPromise = this._audioElement.play();\n      await this._playPromise;\n\n      this._defaultDevices = await getDefaultDevices();\n\n      this._volumeTimeout = setTimeout(\n        volumeEvent,\n        this._options.pollIntervalMs,\n      );\n    } catch (error) {\n      if (error instanceof DiagnosticError) {\n        this._onError(error);\n      } else if (\n        typeof DOMException !== 'undefined' && error instanceof DOMException\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A DOMException has occurred.',\n        ));\n      } else if (\n        typeof DOMError !== 'undefined' && error instanceof DOMError\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A DOMError has occurred.',\n        ));\n      } else {\n        this._onError(new DiagnosticError(\n          undefined,\n          'Unknown error occurred.',\n        ));\n        this._onWarning(error);\n      }\n      this.stop(false);\n    }\n  }\n}\n\nexport namespace OutputTest {\n  /**\n   * Events that the OutputTest will emit as it runs.\n   * Please see [[OutputTest.on]] for how to listen to these\n   * events.\n   */\n  export enum Events {\n    End = 'end',\n    Error = 'error',\n    Volume = 'volume',\n  }\n\n  /**\n   * Options passed to [[OutputTest]] constructor.\n   */\n  export interface Options {\n    /**\n     * An `AudioContext` to be used by the test.\n     * @private\n     */\n    audioContextFactory?: typeof window.AudioContext;\n\n    /**\n     * A constuctor that is used to create an [[AudioElement]], useful for\n     * mocks.\n     * @private\n     */\n    audioElementFactory?: new (...args: any[]) => AudioElement;\n\n    /**\n     * Whether or not to log debug statements to the console.\n     * @private\n     */\n    debug?: boolean;\n\n    /**\n     * The `deviceId` of the audio device to attempt to play audio out of.\n     * This option is directly passed to [HTMLMediaElement.setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n     */\n    deviceId?: string;\n\n    /**\n     * Whether or not to loop the audio.\n     * See [[OutputTest]] for details on the behavior of \"timing out\".\n     * @default true\n     */\n    doLoop?: boolean;\n\n    /**\n     * Duration in milliseconds to run the test for. If this amount of time elapses, the test\n     * is considered \"timed out\".\n     * See [[OutputTest]] for details on the behavior of \"timing out\".\n     * @default Infinity\n     */\n    duration?: number;\n\n    /**\n     * Used to mock the call to `enumerateDevices`.\n     * @private\n     */\n    enumerateDevices?: typeof navigator.mediaDevices.enumerateDevices;\n\n    /**\n     * Set [[OutputTest.Report.didPass]] to true or not upon test timeout.\n     * See [[OutputTest]] for details on the behavior of \"timing out\".\n     * @default true\n     */\n    passOnTimeout?: boolean;\n\n    /**\n     * The polling rate to emit volume events in milliseconds.\n     * @default 100\n     */\n    pollIntervalMs?: number;\n\n    /**\n     * The URI of the audio file to use for the test.\n     */\n    testURI?: string;\n  }\n\n  /**\n   * The test summary that is emitted when the OutputTest ends with event\n   * [[OutputTest.Events.End]].\n   */\n  export interface Report {\n    /**\n     * The `deviceId` of the audio device used to play audio out of.\n     */\n    deviceId: string | undefined;\n\n    /**\n     * Whether or not the test passed. See [[OutputTest]] for determining pass or fail.\n     */\n    didPass: boolean;\n\n    /**\n     * Any errors that occurred during the run-time of the [[OutputTest]].\n     */\n    errors: DiagnosticError[];\n\n    /**\n     * Name of the test, set to [[OutputTest.testName]].\n     */\n    testName: typeof OutputTest.testName;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming: TimeMeasurement;\n\n    /**\n     * The URI of the audio file used during the test.\n     */\n    testURI?: string;\n\n    /**\n     * The volume values emitted by the test during its run-time.\n     */\n    values: number[];\n  }\n\n  /**\n   * Option typing after initialization, so we can have type guarantees.\n   * @private\n   */\n  export type InternalOptions = SubsetRequired<Options,\n    'doLoop' | 'duration' | 'passOnTimeout' | 'pollIntervalMs' | 'testURI'>;\n}\n\n/**\n * Test an audio output device and measures the volume.\n * @param options\n */\nexport function testOutputDevice(\n  options?: OutputTest.Options,\n): OutputTest {\n  return new OutputTest(options);\n}\n"]}
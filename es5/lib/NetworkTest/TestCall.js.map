{"version":3,"file":"TestCall.js","sourceRoot":"","sources":["../../../lib/NetworkTest/TestCall.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,iCAAsC;AAEtC,kCAA0C;AAqH1C;;;;;;;GAOG;AACH;IAA8B,4BAAY;IAyBxC;;;OAGG;IACH,kBAAY,MAAuB;QAAnC,YACE,iBAAO,SA8CR;QA3ED;;WAEG;QACK,oBAAc,GAAkB,EAAE,CAAC;QA4BzC,KAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,eAAe,CAAC;QAE/C,IAAM,qBAAqB,GACzB,MAAM,CAAC,qBAAqB,IAAI,iBAAiB,CAAC;QAEpD,KAAI,CAAC,OAAO,GAAG,IAAI,qBAAqB,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC;QACtE,KAAI,CAAC,UAAU,GAAG,IAAI,qBAAqB,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC;QAEzE,sEAAsE;QACtE,KAAI,CAAC,UAAU,CAAC,aAAa,GAAG,UAAC,EAIhC;gBAHC,oBAAO;YAIP,OAAO,CAAC,SAAS,GAAG,UAAC,YAA0B;gBAC7C,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;YAClD,CAAC,CAAC;YACF,OAAO,CAAC,MAAM,GAAG,UAAC,KAAY;gBAC5B,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,KAAI,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YACzD,CAAC,CAAC;YACF,OAAO,CAAC,OAAO,GAAG,UAAC,KAAY;gBAC7B,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,KAAI,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YAC1D,CAAC,CAAC;QACJ,CAAC,CAAC;QAEF,KAAI,CAAC,gBAAgB,GAAG,KAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QAC1E,KAAI,CAAC,gBAAgB,CAAC,MAAM,GAAG,UAAC,KAAY;YAC1C,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,KAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACtD,CAAC,CAAC;QACF,KAAI,CAAC,gBAAgB,CAAC,OAAO,GAAG,UAAC,KAAY;YAC3C,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,KAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACvD,CAAC,CAAC;QAEF,yBAAyB;QACzB,KAAI,CAAC,sCAAsC,CACzC,KAAI,CAAC,OAAO,EACZ,KAAI,CAAC,UAAU,CAChB,CAAC;QACF,KAAI,CAAC,sCAAsC,CACzC,KAAI,CAAC,UAAU,EACf,KAAI,CAAC,OAAO,CACb,CAAC;QAEF,KAAI,CAAC,+BAA+B,CAAC,KAAI,CAAC,OAAO,CAAC,CAAC;;IACrD,CAAC;IAED;;OAEG;IACH,wBAAK,GAAL;QACE,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;SACtB;QACD,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;SACzB;IACH,CAAC;IAED;;;OAGG;IACG,sCAAmB,GAAzB;;;;;;;wBAEQ,sBAAsB,GAAyB;4BACnD,IAAI,CAAC,OAAO;4BACZ,IAAI,CAAC,UAAU;yBAChB,CAAC,GAAG,CAAC,UAAC,cAAiC,IAAK,OAAA,IAAI,OAAO,CACtD,UAAC,OAAmB;4BAClB,KAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,UAAC,uBAA0C;gCACtE,IAAI,cAAc,KAAK,uBAAuB,EAAE;oCAC9C,OAAO,EAAE,CAAC;iCACX;4BACH,CAAC,CAAC,CAAC;wBACL,CAAC,CACF,EAR4C,CAQ5C,CAAC,CAAC;wBAID,qBAAM,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAA;;wBAD5B,UAAU,GACd,SAAgC;wBAClC,qBAAM,OAAO,CAAC,GAAG,CAAC;gCAChB,qDAAqD;gCACrD,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,UAAU,CAAC;gCAC5C,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC;6BACjD,CAAC,EAAA;;wBAJF,SAIE,CAAC;wBAID,qBAAM,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,EAAA;;wBADhC,aAAa,GACjB,SAAoC;wBACtC,qBAAM,OAAO,CAAC,GAAG,CAAC;gCAChB,qDAAqD;gCACrD,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,aAAa,CAAC;gCAClD,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,aAAa,CAAC;6BACjD,CAAC,EAAA;;wBAJF,SAIE,CAAC;wBAEH,qEAAqE;wBACrE,gDAAgD;wBAChD,oEAAoE;wBACpE,qBAAM,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,GAAG,CAAC,UAAC,OAAsB;gCAClE,OAAA,sBAAc,CAAC,OAAO,EAAE,KAAI,CAAC,gBAAgB,CAAC;4BAA9C,CAA8C,CAAC,CAAC,EAAA;;wBAJlD,qEAAqE;wBACrE,gDAAgD;wBAChD,oEAAoE;wBACpE,SACkD,CAAC;;;;;KACpD;IAED;;OAEG;IACH,mCAAgB,GAAhB;QACE,OAAO,IAAI,CAAC,cAAc,CAAC;IAC7B,CAAC;IAED;;;;;OAKG;IACH,uBAAI,GAAJ,UAAK,IAAY;QACf,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;IAED;;;;;;OAMG;IACK,yDAAsC,GAA9C,UACE,kBAAqC,EACrC,gBAAmC;QAFrC,iBAcC;QAVC,kBAAkB,CAAC,cAAc,GAAG,UAAC,QAAmC;YACtE,IACE,QAAQ,CAAC,SAAS;gBAClB,QAAQ,CAAC,SAAS,CAAC,SAAS;gBAC5B,QAAQ,CAAC,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EACpD;gBACA,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;gBACrE,gBAAgB,CAAC,eAAe,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;aACtD;QACH,CAAC,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACK,kDAA+B,GAAvC,UAAwC,cAAiC;QAAzE,iBA8BC;QA7BC,cAAc,CAAC,uBAAuB,GAAG;YACvC,KAAI,CAAC,cAAc,CAAC,cAAc;gBAChC,KAAI,CAAC,cAAc,CAAC,cAAc,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;YACrD,QAAQ,cAAc,CAAC,eAAe,EAAE;gBACtC,KAAK,YAAY;oBACf,KAAI,CAAC,cAAc,CAAC,cAAc,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oBACtD,MAAM;gBACR,KAAK,WAAW;oBACd,KAAI,CAAC,cAAc,CAAC,cAAc,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oBACpD,KAAI,CAAC,cAAc,CAAC,cAAc,CAAC,QAAQ;wBACzC,KAAI,CAAC,cAAc,CAAC,cAAc,CAAC,GAAG;4BACtC,KAAI,CAAC,cAAc,CAAC,cAAc,CAAC,KAAK,CAAC;oBAC3C,MAAM;aACT;QACH,CAAC,CAAC;QAEF,cAAc,CAAC,0BAA0B,GAAG;YAC1C,KAAI,CAAC,cAAc,CAAC,GAAG,GAAG,KAAI,CAAC,cAAc,CAAC,GAAG,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;YAClE,QAAQ,cAAc,CAAC,kBAAkB,EAAE;gBACzC,KAAK,UAAU;oBACb,KAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oBAC3C,MAAM;gBACR,KAAK,WAAW;oBACd,KAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oBACzC,KAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ;wBAC9B,KAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,GAAG,KAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC;oBAC9D,MAAM;aACT;QACH,CAAC,CAAC;IACJ,CAAC;IACH,eAAC;AAAD,CAAC,AAlND,CAA8B,qBAAY,GAkNzC;AAlNY,4BAAQ;AAoNrB,WAAiB,QAAQ;IACvB;;;OAGG;IACH,IAAY,KAKX;IALD,WAAY,KAAK;QACf,wBAAe,CAAA;QACf,sCAA6B,CAAA;QAC7B,4BAAmB,CAAA;QACnB,sBAAa,CAAA;IACf,CAAC,EALW,KAAK,GAAL,cAAK,KAAL,cAAK,QAKhB;IAmBD;;;;;;OAMG;IACH,IAAY,MAGX;IAHD,WAAY,MAAM;QAChB,iCAAuB,CAAA;QACvB,2BAAiB,CAAA;IACnB,CAAC,EAHW,MAAM,GAAN,eAAM,KAAN,eAAM,QAGjB;AACH,CAAC,EAxCgB,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAwCxB;AA5PY,4BAAQ","sourcesContent":["import { EventEmitter } from 'events';\nimport { NetworkTiming } from '../timing';\nimport { waitForPromise } from '../utils';\n\n/**\n * @internalapi\n */\nexport declare interface TestCall {\n  /**\n   * This event is emitted when the `RTCPeerConnection`'s `RTCDataChannel` is\n   * closed.\n   * @param event [[TestCall.Event.Close]]\n   * @param peerConnection The `RTCPeerConnection` that had its `RTCDataChannel`\n   * closed.\n   * @param rtcEvent The close event.\n   * @private\n   */\n  emit(\n    event: TestCall.Event.Close,\n    peerConnection: RTCPeerConnection,\n    rtcEvent: Event,\n  ): boolean;\n  /**\n   * This event is emitted when the `RTCPeerConnection` receives an ICE\n   * candidate.\n   * @param event [[TestCall.Event.IceCandidate]]\n   * @param peerConnection The `RTCPeerConnection` that received the ICE event.\n   * @param iceEvent The ICE candidate event.\n   * @returns `true` if the event had listeners, `false` otherwise.\n   * @private\n   */\n  emit(\n    event: TestCall.Event.IceCandidate,\n    peerConnection: RTCPeerConnection,\n    iceEvent: RTCPeerConnectionIceEvent,\n  ): boolean;\n  /**\n   * This event is emitted when the `RTCPeerConnection` receives a message on\n   * its `RTCDataChannel`.\n   * @param event [[TestCall.Event.Message]]\n   * @param messageEvent The message event received by the `RTCPeerConnection`.\n   * @returns `true` if the event had listeners, `false` otherwise.\n   * @private\n   */\n  emit(\n    event: TestCall.Event.Message,\n    messageEvent: MessageEvent,\n  ): boolean;\n  /**\n   * This event is emitted when the `RTCPeerConnection`'s `RTCDataChannel` is\n   * opened.\n   * @param event [[TestCall.Event.Open]]\n   * @param peerConnection The `RTCPeerConnection` that received an open event\n   * from its `RTCDataChannel`.\n   * @param rtcEvent The open event.\n   * @returns `true` if the event had listeners, `false` otherwise.\n   * @private\n   */\n  emit(\n    event: TestCall.Event.Open,\n    peerConnection: RTCPeerConnection,\n    rtcEvent: Event,\n  ): boolean;\n\n  /**\n   * Raised when one of the two `RTCPeerConnection`s has their `RTCDataChannel`\n   * closed.\n   * @param event [[TestCall.Event.Close]]\n   * @param listener A callback that expects the following parameters:\n   * - An `RTCPeerConnection` that represents the connection that had its\n   * `RTCDataChannel` closed.\n   * @returns This [[TestCall]] instance.\n   */\n  on(\n    event: TestCall.Event.Close,\n    listener: (peerConnection: RTCPeerConnection) => any,\n  ): this;\n  /**\n   * Raised when one of the two `RTCPeerConnection`s receives an ICE candidate.\n   * @param event [[TestCall.Event.IceCandidate]]\n   * @param listener A callback that expects the following parameters:\n   * - The `RTCPeerConnection` that received the event.\n   * - An `RTCPeerConnectionIceEvent` that the `RTCPeerConnection` received.\n   * @returns This [[TestCall]] instance.\n   */\n  on(\n    event: TestCall.Event.IceCandidate,\n    listener: (\n      peerConnection: RTCPeerConnection,\n      iceEvent: RTCPeerConnectionIceEvent,\n    ) => any,\n  ): this;\n  /**\n   * Raised when the recipient-designated `RTCPeerConnection` receives a message\n   * from the sender.\n   * @param event [[TestCall.Event.Message]]\n   * @param listener A callback that expects the following parameters:\n   * - A `MessageEvent` that the `RTCPeerConnection`'s `RTCDataChannel` receives\n   * @returns This [[TestCall]] instance.\n   */\n  on(\n    event: TestCall.Event.Message,\n    listener: (message: MessageEvent) => any,\n  ): this;\n  /**\n   * Raised when one fo the two `RTCPeerConnection`s receives an open event from\n   * their `RTCDataChannel`.\n   * @param event [[TestCall.Event.Open]]\n   * @param listener A callback that expects the following parameters:\n   * - An `RTCPeerConnection` that represents the connection that had its\n   * `RTCDataChannel` opened.\n   * @returns This [[TestCall]] instance.\n   */\n  on(\n    event: TestCall.Event.Open,\n    listener: (peerConnection: RTCPeerConnection) => any,\n  ): this;\n}\n\n/**\n * Creates two PeerConnections that attempt to connect to each other through\n * any ICE servers given by the parameter\n * [[TestCall.Options.peerConnectionConfig]].\n * Provides a `send` helper function to send data from the `sender` to the\n * `receiver`.\n * @private\n */\nexport class TestCall extends EventEmitter {\n  /**\n   * Network event time measurements.\n   */\n  private _networkTiming: NetworkTiming = {};\n  /**\n   * The recipient-designated `RTCPeerConnection`, will receive a message\n   * from the [[_sender]].\n   */\n  private _recipient: RTCPeerConnection;\n  /**\n   * The `RTCDataChannel` belonging to the sender-designated\n   * `RTCPeerConnection`.\n   */\n  private _sendDataChannel: RTCDataChannel;\n  /**\n   * The sender-designated `RTCPeerConnection`, will send a message to the\n   * [[_recipient]].\n   */\n  private _sender: RTCPeerConnection;\n  /**\n   * The timeout before failing.\n   */\n  private _timeoutDuration: number;\n\n  /**\n   * Constructor for the [[TestCall]] helper class. Creates the two\n   * `RTCPeerConnection`s and maintains their connection to each other.\n   */\n  constructor(config: TestCall.Config) {\n    super();\n\n    this._timeoutDuration = config.timeoutDuration;\n\n    const peerConnectionFactory: typeof RTCPeerConnection =\n      config.peerConnectionFactory || RTCPeerConnection;\n\n    this._sender = new peerConnectionFactory(config.peerConnectionConfig);\n    this._recipient = new peerConnectionFactory(config.peerConnectionConfig);\n\n    // Set up data channels and listeners on the recipient and the sender.\n    this._recipient.ondatachannel = ({\n      channel,\n    }: {\n      channel: RTCDataChannel;\n    }): void => {\n      channel.onmessage = (messageEvent: MessageEvent): void => {\n        this.emit(TestCall.Event.Message, messageEvent);\n      };\n      channel.onopen = (event: Event): void => {\n        this.emit(TestCall.Event.Open, this._recipient, event);\n      };\n      channel.onclose = (event: Event): void => {\n        this.emit(TestCall.Event.Close, this._recipient, event);\n      };\n    };\n\n    this._sendDataChannel = this._sender.createDataChannel('sendDataChannel');\n    this._sendDataChannel.onopen = (event: Event): void => {\n      this.emit(TestCall.Event.Open, this._sender, event);\n    };\n    this._sendDataChannel.onclose = (event: Event): void => {\n      this.emit(TestCall.Event.Close, this._sender, event);\n    };\n\n    // Forward ICE candidates\n    this._bindPeerConnectionIceCandidateHandler(\n      this._sender,\n      this._recipient,\n    );\n    this._bindPeerConnectionIceCandidateHandler(\n      this._recipient,\n      this._sender,\n    );\n\n    this._bindPeerConnectionTimeHandlers(this._sender);\n  }\n\n  /**\n   * Close the `sender` and `recipient` PCs.\n   */\n  close(): void {\n    if (this._sender) {\n      this._sender.close();\n    }\n    if (this._recipient) {\n      this._recipient.close();\n    }\n  }\n\n  /**\n   * Create offers and answers for the PCs and set them. This starts the\n   * ICE connection process between the two.\n   */\n  async establishConnection(): Promise<void> {\n    // Set up a promise that resolves when the data channel is open\n    const waitForDataChannelOpen: Array<Promise<void>> = [\n      this._sender,\n      this._recipient,\n    ].map((peerConnection: RTCPeerConnection) => new Promise(\n      (resolve: () => void): void => {\n        this.on(TestCall.Event.Open, (connectedPeerConnection: RTCPeerConnection): void => {\n          if (peerConnection === connectedPeerConnection) {\n            resolve();\n          }\n        });\n      },\n    ));\n\n    // Create the offer on the sender\n    const senderDesc: RTCSessionDescriptionInit =\n      await this._sender.createOffer();\n    await Promise.all([\n      // Set this description for the local and remote legs\n      this._sender.setLocalDescription(senderDesc),\n      this._recipient.setRemoteDescription(senderDesc),\n    ]);\n\n    // Create the answer from the recipient\n    const recipientDesc: RTCSessionDescriptionInit =\n      await this._recipient.createAnswer();\n    await Promise.all([\n      // Set this description for the local and remote legs\n      this._recipient.setLocalDescription(recipientDesc),\n      this._sender.setRemoteDescription(recipientDesc),\n    ]);\n\n    // Once the offer and answer are set, the connection should start and\n    // eventually be established between the two PCs\n    // We can wait for the data channel to open on both sides to be sure\n    await Promise.all(waitForDataChannelOpen.map((promise: Promise<void>) =>\n      waitForPromise(promise, this._timeoutDuration)));\n  }\n\n  /**\n   * Returns all recorded network time measurements.\n   */\n  getNetworkTiming(): NetworkTiming {\n    return this._networkTiming;\n  }\n\n  /**\n   * Helper function for sending data\n   * @param data a string of characters that will be sent from one end of the\n   * [[TestCall]] to the other, specifically from [[TestCall._sender]] to\n   * [[TestCall._recipient]].\n   */\n  send(data: string): void {\n    this._sendDataChannel.send(data);\n  }\n\n  /**\n   * Bind the ice candidate handler to the peer connection.\n   * @param peerConnectionFrom The peer connection to bind the ice candidate\n   * handler to.\n   * @param peerConnectionTo The peer connection to forward the ice candidate\n   * to.\n   */\n  private _bindPeerConnectionIceCandidateHandler(\n    peerConnectionFrom: RTCPeerConnection,\n    peerConnectionTo: RTCPeerConnection,\n  ): void {\n    peerConnectionFrom.onicecandidate = (iceEvent: RTCPeerConnectionIceEvent) => {\n      if (\n        iceEvent.candidate &&\n        iceEvent.candidate.candidate &&\n        iceEvent.candidate.candidate.indexOf('relay') !== -1\n      ) {\n        this.emit(TestCall.Event.IceCandidate, peerConnectionFrom, iceEvent);\n        peerConnectionTo.addIceCandidate(iceEvent.candidate);\n      }\n    };\n  }\n\n  /**\n   * Bind time measuring event handlers.\n   * @param peerConnection The peer connection to bind the time measuring\n   * event handlers to.\n   */\n  private _bindPeerConnectionTimeHandlers(peerConnection: RTCPeerConnection): void {\n    peerConnection.onconnectionstatechange = (): void => {\n      this._networkTiming.peerConnection =\n        this._networkTiming.peerConnection || { start: 0 };\n      switch (peerConnection.connectionState) {\n        case 'connecting':\n          this._networkTiming.peerConnection.start = Date.now();\n          break;\n        case 'connected':\n          this._networkTiming.peerConnection.end = Date.now();\n          this._networkTiming.peerConnection.duration =\n            this._networkTiming.peerConnection.end -\n            this._networkTiming.peerConnection.start;\n          break;\n      }\n    };\n\n    peerConnection.oniceconnectionstatechange = (): void => {\n      this._networkTiming.ice = this._networkTiming.ice || { start: 0 };\n      switch (peerConnection.iceConnectionState) {\n        case 'checking':\n          this._networkTiming.ice.start = Date.now();\n          break;\n        case 'connected':\n          this._networkTiming.ice.end = Date.now();\n          this._networkTiming.ice.duration =\n            this._networkTiming.ice.end - this._networkTiming.ice.start;\n          break;\n      }\n    };\n  }\n}\n\nexport namespace TestCall {\n  /**\n   * Events that the [[TestCall]] helper class may emit as the `PeerConnection`s\n   * communicate with each other.\n   */\n  export enum Event {\n    Close = 'close',\n    IceCandidate = 'iceCandidate',\n    Message = 'message',\n    Open = 'open',\n  }\n  /**\n   * Options for the [[TestCall]] class.\n   */\n  export interface Config {\n    /**\n     * Configurations to pass to the `PeerConnection` class.\n     */\n    peerConnectionConfig: RTCConfiguration;\n    /**\n     * Used to mock the peer connection.\n     * @private\n     */\n    peerConnectionFactory?: typeof RTCPeerConnection;\n    /**\n     * Timeout for the `RTCDataChannel`.\n     */\n    timeoutDuration: number;\n  }\n  /**\n   * Used in conjunction with the events raised from this class to determine\n   * which leg of the call is connected.\n   * For example, the [[TestCall.Events.Open]] event is raised with the information\n   * `Recipient` or `Sender` signifying which side of the data channel was just\n   * opened.\n   */\n  export enum CallId {\n    Recipient = 'recipient',\n    Sender = 'sender',\n  }\n}\n"]}